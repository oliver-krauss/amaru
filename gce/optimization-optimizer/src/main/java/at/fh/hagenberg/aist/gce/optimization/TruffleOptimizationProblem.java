/*
 * Copyright (c) 2022 the original author or authors.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 *
 */

package at.fh.hagenberg.aist.gce.optimization;

import at.fh.hagenberg.aist.gce.optimization.executor.AbstractExecutor;
import at.fh.hagenberg.aist.gce.optimization.language.Accessor;
import at.fh.hagenberg.aist.gce.optimization.test.TruffleOptimizationTest;
import at.fh.hagenberg.aist.gce.optimization.test.TruffleOptimizationTestComplexity;
import at.fh.hagenberg.aist.gce.optimization.util.*;
import at.fh.hagenberg.aist.gce.optimization.util.strategy.CreationConfiguration;
import com.oracle.truffle.api.CallTarget;
import science.aist.seshat.Logger;
import at.fh.hagenberg.machinelearning.algorithm.ga.RepackagingHelper;
import at.fh.hagenberg.machinelearning.analytics.graph.nodes.NodeWrapper;
import at.fh.hagenberg.machinelearning.core.Configurable;
import at.fh.hagenberg.machinelearning.core.Solution;
import at.fh.hagenberg.machinelearning.core.options.Descriptor;
import com.oracle.truffle.api.nodes.Node;
import com.oracle.truffle.api.nodes.NodeUtil;
import org.neo4j.ogm.annotation.Id;
import org.neo4j.ogm.annotation.Relationship;
import org.neo4j.ogm.annotation.Transient;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

/**
 * This problem describes the optimization of a sub-tree in a truffle language
 * It is independent of any truffle language. If language specific problem-depsriptions are needed extend from this class
 * Created by Oliver Krauss on 10.02.2017.
 */
public class TruffleOptimizationProblem implements Configurable {

    /**
     * Id generated by database
     */
    @Id
    private Long id;

    /**
     * Human readable description for easier analysis
     */
    private String description = "";

    /**
     * Truffle langugae the problem is encoded in
     */
    private String language;

    /**
     * Code to provide context for optimized function
     */
    private String code;

    /**
     * Name of function to be optimized
     */
    private String function;

    /**
     * Name of function to be optimized
     */
    private String entryPoint;


    /**
     * The sub-tree parent node to be optimized. (only the children will be touched, not the node itself!)
     */
    @Transient
    private Node node;

    @Transient
    private Logger logger = Logger.getInstance();

    /**
     * = node; The Wrapped (Neo4J) Version of the node.
     */
    @Relationship(type = "ORIGIN", direction = Relationship.OUTGOING)
    private NodeWrapper wrappedNode;

    /**
     * Describes the tests that the target tree should be able to solve
     */
    @Relationship(type = "TEST_CASE", direction = Relationship.OUTGOING)
    private Set<TruffleOptimizationTestComplexity> tests;

    @Relationship(type = "ORIGINAL_AST_SOLUTION", direction = Relationship.OUTGOING)
    private Solution<TruffleOptimizationSolution, TruffleOptimizationProblem> originalSolution;

    @Relationship(type = "BEST_KNOWN_SOLUTION", direction = Relationship.OUTGOING)
    private Solution<TruffleOptimizationSolution, TruffleOptimizationProblem> bestKnownSolution;

    /**
     * Amount of repeats the node will be executed for evaluation
     */
    @Transient
    private int repeats = 1;

    /**
     * Information about the truffle language and its nodes
     */
    @Transient
    private TruffleLanguageSearchSpace searchSpace;

    /**
     * Human readable version of the fitness function. Needed to identify the run concerning different quality requirements
     */
    private String fitnessFunction;

    /**
     * Containing the problem configuration for the search space (ex. depth and height)
     */
    @Transient
    private CreationConfiguration configuration;

    public TruffleOptimizationProblem() {

    }

    public TruffleOptimizationProblem(String language, String code, String entryPoint, String function, Node node, Node bestKnownSolution, TruffleLanguageSearchSpace searchSpace, CreationConfiguration configuration, Set<TruffleOptimizationTest> tests, int repeats, String fitnessFunction) {
        if (tests == null) {
            logger.warn("No tests provided.");
            tests = new HashSet<>();
        }

        this.language = language;
        this.code = code;
        this.entryPoint = entryPoint;
        this.function = function;
        this.node = node;
        this.wrappedNode = NodeWrapper.wrap(node);
        this.searchSpace = searchSpace;
        this.configuration = configuration;
        this.tests = tests.stream().map(x -> new TruffleOptimizationTestComplexity(this, x)).collect(Collectors.toSet());
        this.repeats = repeats;
        this.fitnessFunction = fitnessFunction;
        this.originalSolution = RepackagingHelper.createSolution(this, node);
        if (bestKnownSolution != null) {
            this.bestKnownSolution = RepackagingHelper.createSolution(this, bestKnownSolution);
        }
        calculateProblemStatistics();
        getHash();
    }

    public Node getNode() {
        return node;
    }

    public NodeWrapper getWrappedNode() {
        return wrappedNode;
    }

    public Set<TruffleOptimizationTestComplexity> getTests() {
        return tests;
    }

    public int getRepeats() {
        return repeats;
    }

    public TruffleLanguageSearchSpace getSearchSpace() {
        return searchSpace;
    }

    public Solution<TruffleOptimizationSolution, TruffleOptimizationProblem> getOriginalSolution() {
        return originalSolution;
    }

    public Solution<TruffleOptimizationSolution, TruffleOptimizationProblem> getBestKnownSolution() {
        return bestKnownSolution;
    }

    private void estimateProblemSize(int maxTreeWidth, int maxTreeDepth, double avgTreeWidth, double avgTreeDepth) {
        // first of all lets get an estimate
        // worst case
        double bestScen = 1; // single node that fixes all our problems
        double worstScen = 1;
        for (int i = 2; i <= maxTreeDepth; i++) {
            worstScen += Math.pow(maxTreeWidth, i);
        }
        double avgScen = 1;
        for (int i = 2; i <= avgTreeDepth; i++) {
            avgScen += Math.pow(avgTreeWidth, i);
        }

        System.out.println("nodes best/avg/worst " + bestScen + "/" + this.searchSpace.getInstantiableNodes().size() + "^" + avgScen + "/" + this.searchSpace.getInstantiableNodes().size() + "^" + worstScen);

    }

    public void calculateProblemStatistics() {
        // Check what the input is based on
        System.out.println("Size of input: " + NodeUtil.countNodes(node));
        System.out.println("MaxDepth of input: " + ExtendedNodeUtil.maxDepth(node));
        System.out.println("AvgDepth of input: " + ExtendedNodeUtil.avgDepth(node));
        System.out.println("MaxWidth of input: " + ExtendedNodeUtil.maxWidth(node));
        System.out.println("AvgWidth of input: " + ExtendedNodeUtil.avgWidth(node));

        // Estimate the search spaces
        System.out.println("Estimate search space input: ");
        estimateProblemSize(ExtendedNodeUtil.maxWidth(node), ExtendedNodeUtil.maxDepth(node), ExtendedNodeUtil.avgWidth(node), ExtendedNodeUtil.avgDepth(node));
        System.out.println("Estimate search space restricted: ");
        estimateProblemSize(configuration.getMaxWidth(), configuration.getMaxDepth(), configuration.getMaxWidth() / 2, configuration.getMaxDepth() / 2);

        System.out.println("all possible solutions " + new SearchSpaceSizeEstimationHelper().estimateAllSolutions(configuration, this.searchSpace));
    }


    /**
     * Returns a hash thet identifies a problem statement solely by its tests
     *
     * @return id of the tests
     */
    private String testHash = null;

    public String getTestHash() {
        if (testHash == null) {
            byte[][] hashes = new byte[tests.size()][];
            AtomicInteger i = new AtomicInteger();
            tests.stream().sorted().forEach(x -> {
                hashes[i.get()] = HashUtil.decodeHash(x.getTest().getHash());
                i.getAndIncrement();
            });
            testHash = HashUtil.hashAndEncode(hashes);
        }
        return testHash;
    }

    private String hash = null;

    /**
     * Returns a hash thet identifies the unit-test values and NAME for this optimization problem.
     * It guarantees a solution-identity dependent on requirements but not on settings of the algorithm
     * (note that if you have the EXACT same tests AND fitnessFN AND description name this will not be unique (as we don't hash the code)
     *
     * @return id of the tests AND the fitness function
     */
    public String getHash() {
        if (hash == null) {
            hash = HashUtil.hashAndEncode((function + entryPoint + description + fitnessFunction).getBytes());
        }
        return hash;
    }

    public String getFitnessFunction() {
        return fitnessFunction;
    }

    public CreationConfiguration getConfiguration() {
        return configuration;
    }

    /**
     * Copies the entire problem so it can be modified and stored as a new problem in the DB
     * all objects are references not copies,
     * all collections are copies, but do reference the objects in the collections
     * all Relationship-Entities are actual copies (so as not to point to the wrong problem)
     * <p>
     * Note: the tests ARE copies, as they are a relationship-entity that should't be modified (due to id)
     *
     * @param problem to be copied
     * @return a copy of the problem
     */
    public static TruffleOptimizationProblem copy(TruffleOptimizationProblem problem) {
        TruffleOptimizationProblem copy = new TruffleOptimizationProblem();
        copy.setDescription(problem.getDescription());
        copy.language = problem.language;
        copy.code = problem.code;
        copy.function = problem.function;
        copy.node = problem.node;
        copy.wrappedNode = problem.wrappedNode;
        copy.configuration = problem.configuration;
        copy.tests = new HashSet<>();
        problem.tests.forEach(x -> {
            copy.tests.add(new TruffleOptimizationTestComplexity(x.getNodeCount(), x.getSpezialisations(), x.getNodes(), copy, x.getTest()));
        });
        copy.originalSolution = problem.originalSolution;
        copy.bestKnownSolution = problem.bestKnownSolution;
        copy.repeats = problem.repeats;
        copy.searchSpace = problem.searchSpace;
        copy.fitnessFunction = problem.fitnessFunction;
        return copy;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public void setWrappedNode(NodeWrapper wrappedNode) {
        this.wrappedNode = wrappedNode;
    }

    public void setOriginalSolution(Solution<TruffleOptimizationSolution, TruffleOptimizationProblem> originalSolution) {
        this.originalSolution = originalSolution;
    }

    public void setBestKnownSolution(Solution<TruffleOptimizationSolution, TruffleOptimizationProblem> bestKnownSolution) {
        this.bestKnownSolution = bestKnownSolution;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    @Override
    public Map<String, Descriptor> getOptions() {
        // Note: not publishing id, code, tests, originalSolution, bestKnownSolution

        Map<String, Descriptor> options = new HashMap<>();
        options.put("description", new Descriptor<>(description));
        options.put("repeats", new Descriptor<>(repeats));
        options.put("configuration", new Descriptor<>(configuration == null ? new CreationConfiguration(5, 5, Double.MAX_VALUE) : configuration));
        return options;
    }

    @Override
    public boolean setOption(String name, Descriptor descriptor) {
        try {
            switch (name) {
                case "description":
                    setDescription((String) descriptor.getValue());
                    break;
                case "repeats":
                    repeats = (int) descriptor.getValue();
                    break;
                case "configuration":
                    configuration = (CreationConfiguration) descriptor.getValue();
                    break;
                case "node":
                    node = (Node) descriptor.getValue();
                case "searchSpace":
                    searchSpace = (TruffleLanguageSearchSpace) descriptor.getValue();
            }
        } catch (Exception e) {
            return false;
        }
        return true;
    }

    public String getLanguage() {
        return language;
    }

    public String getCode() {
        return code;
    }

    public String getFunction() {
        return function;
    }

    public String getEntryPoint() {
        return entryPoint;
    }

    public void setBenchmark() {
        this.description = function + "_BENCHMARK";
        this.fitnessFunction = "Performance-0.3 * 1.0";
        this.hash = null;
        // check if we have a benchmark function
        Accessor access = Accessor.getAccessor(AbstractExecutor.ACCESSOR_PREFIX + language);
        CallTarget benchmarkTarget = access.getCallTarget(function + "_benchmark");
        if (benchmarkTarget != null) {
            this.entryPoint = function + "_benchmark";
        } else {
            System.out.println("WARNING: The function " + function + " has no benchmark option");
        }
        this.repeats = 200000;
    }

    public void setConfiguration(CreationConfiguration creationConfiguration) {
        this.configuration = creationConfiguration;
    }

    public void setEntryPoint(String entryPoint) {
        this.entryPoint = entryPoint;
    }
}
