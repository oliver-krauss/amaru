/*
 * Copyright (c) 2022 the original author or authors.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 *
 */

package at.fh.hagenberg.aist.gce.optimization.test;

import at.fh.hagenberg.aist.gce.optimization.util.HashUtil;
import org.neo4j.ogm.annotation.Id;
import org.neo4j.ogm.annotation.NodeEntity;
import org.neo4j.ogm.annotation.Transient;

import java.nio.charset.StandardCharsets;
import java.util.Collection;
import java.util.Collections;

/**
 * A value used in a test.
 */
@NodeEntity
public class TruffleTestValue {

    /**
     * Helper variable that checks if the test value needs to be repaired (every time it is loaded from DB :( )
     */
    @Transient
    private boolean FIX = true;

    /**
     * Id generated by database
     */
    @Id
    private Long id;

    /**
     * Hash uniquely identifying this exact test value
     */
    private String hash;

    /**
     * The value will be given as is to the program (NULL is a valid value!)
     */
    private Object value;

    /**
     * The type describes the type as used in the target language.
     * It should NOT correspond to the java-type being used, but rather to the language-type that it will be transformed to
     * The type is optional, but since it is used for research purposes it should be set
     */
    private String type;

    public TruffleTestValue() {
    }

    public TruffleTestValue(Object value) {
        this.value = value;
    }

    public TruffleTestValue(Object value, String type) {
        this.value = value;
        fix();
        this.type = type;
    }

    public String getHash() {
        if (hash == null) {
            byte[][] hashes = new byte[(value != null ? 1 : 0) + (type != null ? 1 : 0)][];
            int i = 0;
            if (value != null) {
                hashes[i] = HashUtil.hash(ValueDefinitions.valueToString(value).getBytes(StandardCharsets.UTF_8));
                i++;
            }
            if (type != null) {
                hashes[i] = HashUtil.hash(type.getBytes());
            }
            hash = HashUtil.hashAndEncode(hashes);
        }
        return hash;
    }

    public void setHash(String hash) {
        this.hash = hash;
    }

    public Object getValue() {
        fix();
        return value;
    }

    public String getType() {
        switch (type) {
            case "[I":
                type = "int_array";
                break;
            case "[F":
                type = "float_array";
                break;
        }
        return type;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    /**
     * Very ugly method that we need because Neo4J creates a big problem:
     * It doesn't store the correct datatypes when persisting (ex. every int becomes a long).
     * <p>
     * Thus we need to manually repair the datatype after loading
     */
    private void fix() {
        if (!FIX || type == null) {
            return;
        }
        switch (type) {
            case "[I":
                type = "int_array";
                break;
            case "[F":
                type = "float_array";
                break;
        }
        switch (type) {
            case "int":
                value = Integer.parseInt(String.valueOf(value));
                break;
            case "char":
                value = String.valueOf(value).charAt(0);
                break;
            case "double":
                value = Double.parseDouble(String.valueOf(value));
                break;
            case "float":
                value = Float.parseFloat(String.valueOf(value));
                break;
            case "string":
            case "java.lang.String":
                value = String.valueOf(value);
                break;
            case "int_array":
                if (value instanceof int[]) {
                    break;
                } else if (value != null && value.getClass().getName().contains("UnmodifiableRandomAccessList")) {
                    Collection valCol = (Collection) this.value;
                    int[] array = new int[valCol.size()];
                    int i = 0;
                    for (Object o : valCol) {
                        array[i++] = ((Long) o).intValue();
                    }
                    value = array;
                    break;
                }
                String[] values = String.valueOf(value).split(",");
                int[] array = new int[values.length];
                for (int i = 0; i < values.length; i++) {
                    array[i] = Integer.parseInt(values[i]);
                }
                value = array;
                break;
            case "float_array":
                if (value instanceof float[]) {
                    break;
                } else if (value != null && value.getClass().getName().contains("UnmodifiableRandomAccessList")) {
                    Collection valCol = (Collection) this.value;
                    float[] arrayF = new float[valCol.size()];
                    int i = 0;
                    for (Object o : valCol) {
                        arrayF[i++] = ((Double) o).floatValue();
                    }
                    value = arrayF;
                    break;
                }
                String[] valuesF = String.valueOf(value).split(",");
                float[] arrayF = new float[valuesF.length];
                for (int i = 0; i < valuesF.length; i++) {
                    arrayF[i] = Float.parseFloat(valuesF[i]);
                }
                value = arrayF;
                break;
            default:
                throw new RuntimeException("Type " + type + " not yet implemented in data load");
        }
        FIX = false;
    }

    /**
     * Returns a similarity scoring for truffle test values
     * If the values are from the same type a value between 0 and 1 will be returned
     * 0 meaning the value is exactly the same (null == null is 0)
     * 1 meaning the complete opposite (Int.MIN to Int.Max)
     * <p>
     * If the values are of a different type, the comparison will return 2
     * If the values are of the same type but one is null, 1.5 will be returned
     *
     * @return comparison on a scale from 0..1 (errors in type up to ..2)
     */
    public double compare(TruffleTestValue value) {
        // TODO #63 We can improve this by dividing via the largest observed val in the set instead of XXX.MAX_VALUE
        // TODO #63 this also has overlap with the accuracy cachete evaluator in functionality
        if (type != null && this.type.equals(value.type)) {
            if (this.value == null && value.value == null) {
                return 0;
            }
            if (this.value == null || value.value == null) {
                return 1.5;
            }
            switch (type) {
                case "int":
                    return Math.abs((int) this.value - (int) value.value) / (double) Integer.MAX_VALUE;
                case "char":
                    return Math.abs((char) this.value - (char) value.value) / (double) Character.MAX_VALUE;
                case "double":
                    // Note: this is only accurrate down to 44 points after the comma
                    return Math.abs(checkInfinity((double) this.value) - checkInfinity((double) value.value)) / Double.MAX_VALUE;
                case "float":
                    // Note: this is only accurate down to 15 points after the comma
                    return Math.abs(checkInfinity((float) this.value) - checkInfinity((float) value.value)) / (double) Float.MAX_VALUE;
                case "java.lang.String":
                    return computeLevenshteinDistance((String) this.value, (String) value.value) / (double) Integer.MAX_VALUE;
                case "int_array":
                    double quality = 0;
                    int[] thisVal = (int[]) this.value;
                    int[] thatVal = (int[]) value.value;
                    if (thisVal.length != thatVal.length) {
                        return 1.5;
                    }
                    for (int i = 0; i < thisVal.length; i++) {
                        quality += Math.abs(thisVal[i] - thatVal[i]) / (double) Integer.MAX_VALUE;
                    }
                    return quality / (double) thisVal.length;
                case "float_array":
                    double qualityF = 0;
                    float[] thisValF = (float[]) this.value;
                    float[] thatValF = (float[]) value.value;
                    if (thisValF.length != thatValF.length) {
                        return 1.5;
                    }
                    for (int i = 0; i < thisValF.length; i++) {
                        qualityF += Math.abs(checkInfinity(thisValF[i]) - checkInfinity(thatValF[i])) / (double) Float.MAX_VALUE;
                    }
                    return qualityF / (double) thisValF.length;
                default:
                    throw new RuntimeException("Type " + type + " not yet implemented in comparison");
            }
        }
        return 2; // different types
    }

    private double checkInfinity(double value) {
        return Double.isInfinite(value) || Double.isNaN(value) ? Double.MAX_VALUE : value;
    }

    private float checkInfinity(float value) {
        return Float.isInfinite(value) || Float.isNaN(value) ? Float.MAX_VALUE : value;
    }

    private int minimum(int a, int b, int c) {
        return Math.min(Math.min(a, b), c);
    }

    private int computeLevenshteinDistance(CharSequence str1, CharSequence str2) {
        int[][] distance = new int[str1.length() + 1][str2.length() + 1];

        for (int i = 0; i <= str1.length(); i++)
            distance[i][0] = i;
        for (int j = 1; j <= str2.length(); j++)
            distance[0][j] = j;

        for (int i = 1; i <= str1.length(); i++)
            for (int j = 1; j <= str2.length(); j++)
                distance[i][j] = minimum(distance[i - 1][j] + 1,
                        distance[i][j - 1] + 1,
                        distance[i - 1][j - 1] + ((str1.charAt(i - 1) == str2.charAt(j - 1)) ? 0 : 1));

        return distance[str1.length()][str2.length()];
    }


}
