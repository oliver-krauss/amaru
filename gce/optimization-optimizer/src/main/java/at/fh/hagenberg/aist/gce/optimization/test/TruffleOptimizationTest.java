/*
 * Copyright (c) 2022 the original author or authors.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 *
 */

package at.fh.hagenberg.aist.gce.optimization.test;


import at.fh.hagenberg.aist.gce.optimization.util.HashUtil;
import at.fh.hagenberg.machinelearning.analytics.graph.nodes.OrderedRelationship;
import org.neo4j.ogm.annotation.*;

import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

/**
 * A Truffle Test Target is ONE SINGLE unittest for a program that should happen in a call
 */
@NodeEntity
public class TruffleOptimizationTest implements Comparable<TruffleOptimizationTest> {

    /**
     * Id generated by database
     */
    @Id
    private Long id;

    /**
     * The Arguments that are passed to the problem (optional!)
     */
    @Transient
    private Object[] inputArguments;

    /**
     * The same as inputArguments but with additional information. Exclusively for logging and analysis
     */
    @Relationship(type = "TEST_INPUT", direction = Relationship.INCOMING)
    private Set<OrderedTestInput> input;

    /**
     * The Output that should be generated in this test
     */
    @Transient
    private Object outputValue;

    /**
     * The same as outputValue but with additional information. Exclusively for logging and analysis
     */
    @Relationship(type = "TEST_OUTPUT", direction = Relationship.OUTGOING)
    private TruffleTestValue output;

    /**
     * Hash uniquely identifying this exact test
     */
    private String hash;

    @Transient
    private boolean initialized = false;


    public TruffleOptimizationTest() {
    }

    public TruffleOptimizationTest(List<TruffleTestValue> input, TruffleTestValue output) {
        if (input != null) {
            AtomicInteger i = new AtomicInteger();
            setInput(input.stream().map(x -> new OrderedTestInput(this, x, i.getAndIncrement())).collect(Collectors.toSet()));
        }
        setOutput(output);
    }

    public TruffleOptimizationTest(Set<OrderedTestInput> input, TruffleTestValue output) {
        setInput(input);
        setOutput(output);
    }

    public List<TruffleTestValue> getInput() {
        return input.stream().map(OrderedTestInput::getInput).collect(Collectors.toList());
    }

    public Set<OrderedTestInput> getInputSet() {
        return input;
    }

    public TruffleTestValue getOutput() {
        return output;
    }

    public void setInput(Set<OrderedTestInput> input) {
        if (input == null) {
            return;
        }
        this.input = new TreeSet<>(input);
        this.inputArguments = this.input.stream().map(x -> x.getInput().getValue()).toArray();
    }

    public void setOutput(TruffleTestValue output) {
        if (output == null) {
            return;
        }
        this.outputValue = output.getValue();
        this.output = output;
    }

    public void setHash(String hash) {
        this.hash = hash;
    }

    public Object[] getInputArguments() {
        if (!initialized) {
            init();
        }
        return inputArguments;
    }

    /**
     * DANGER: Only use this setter after setting the input, as the input setter overrides the input arguments
     * This setter is for "special" languages, where we need to modify the arguments to work with the language manually
     *
     * @param inputArguments
     */
    public void setInputArguments(Object[] inputArguments) {
        this.inputArguments = inputArguments;
    }

    public Object getOutputValue() {
        if (!initialized) {
            init();
        }
        return outputValue;
    }

    private void init() {
        initialized = true;
        setOutput(output);
        setInput(input);
    }

    public String getHash() {
        if (hash == null) {
            byte[][] hashes = new byte[(this.input != null ? input.size() : 0) + (this.output != null ? 1 : 0)][];
            int i = 0;
            if (output != null) {
                hashes[0] = HashUtil.hash(HashUtil.decodeHash(output.getHash()));
                i = 1;
            }
            if (input != null) {
                Iterator<OrderedTestInput> inIt = input.iterator();
                while (inIt.hasNext()) {
                    hashes[i] = HashUtil.hash(HashUtil.decodeHash(inIt.next().getInput().getHash()));
                    i++;
                }
            }
            hash = HashUtil.hashAndEncode(hashes);
        }
        return hash;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    @Override
    public int compareTo(TruffleOptimizationTest o) {
        return this.getHash().compareTo(o.getHash());
    }
}
